{"version":3,"sources":["@crema/core/AppsContainer/AppSidebar.js","@crema/core/AppsContainer/AppContainerWrapper.js","@crema/core/AppsContainer/index.js","../../../../src/react/hooks/useSyncExternalStore.ts","../../../../src/react/hooks/useQuery.ts","components/CappContaner/index.jsx","query/orderReoprt/getOrder.js","../../../../src/react/hooks/useLazyQuery.ts","pages/reports/financialReports/index.js"],"names":["AppSidebar","props","isAppDrawerOpen","sidebarContent","dispatch","useDispatch","Slide","direction","in","mountOnEnter","unmountOnExit","Box","sx","height","width","lg","Hidden","lgUp","Drawer","open","onClose","onToggleAppDrawer","position","drawerClasses","paper","zIndex","lgDown","Card","style","getMainHeaderHeight","navStyle","screenSize","NavStyle","BIT_BUCKET","AppContainerWrapper","children","footer","rest","display","xs","sm","md","xl","AppsContainer","useSelector","common","useLayoutContext","title","fullView","flex","flexDirection","overflow","margin","padding","sxStyle","marginTop","alignItems","mb","mt","IconButton","edge","marginRight","theme","spacing","color","onClick","size","Zoom","transitionDelay","component","variant","fontSize","fontWeight","Fonts","SEMI_BOLD","pl","cardStyle","AppInfoView","defaultProps","didWarnUncachedGetSnapshot","useSyncExternalStore","React","subscribe","getSnapshot","getServerSnapshot","value","__DEV__","invariant","inst","forceUpdate","canUseLayoutEffect","Object","assign","checkIfSnapshotChanged","_a","useQuery","query","options","create","useInternalState","useApolloClient","client","stateRef","useRef","current","InternalState","state","useState","setTick","tick","previous","asyncResolveFns","Set","optionsToIgnoreOnce","canUseWeakSet","WeakSet","ssrDisabledResult","maybeDeepFreeze","loading","data","error","networkStatus","NetworkStatus","skipStandbyResult","ready","toQueryResultCache","canUseWeakMap","WeakMap","Map","verifyDocumentType","DocumentType","Query","previousResult","result","previousData","this","Promise","resolve","_this","add","watchQueryOptions","renderPromises","useContext","getApolloContext","useOptions","obsQuery","useObservableQuery","useCallback","onNext","getCurrentResult","equal","setResult","subscription","onError","last","unsubscribe","resetLastResults","hasOwnProperty","call","disableNetworkFetches","unsafeHandlePartialRefetch","queryResult","toQueryResult","forEach","clear","createWatchQueryOptions","queryHookOptions","currentWatchQueryOptions","has","observable","delete","reobserve","getObsQueryOptions","onCompleted","prototype","ssr","skip","fetchPolicy","toMerge","globalDefaults","defaultOptions","watchQuery","push","compact","reduce","mergeOptions","otherOptions","variables","getDefaultFetchPolicy","_d","initialFetchPolicy","getSSRObservable","obsQueryFields","useMemo","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","ssrAllowed","registerSSRObservable","addObservableQueryPromise","nextResult","handleErrorOrCompleted","get","resultWithoutPartial","set","called","isNonEmptyArray","errors","ApolloError","graphQLErrors","partial","partialRefetch","keys","length","CAppContaner","description","Component","source","buttonCompMethod","messages","useIntl","viewSource","setToggleViewSource","animation","setAnimation","delay","py","pb","px","minHeight","boxSizing","BOLD","marginBottom","subheader","root","action","setTimeout","pt","justifyContent","p","backgroundColor","palette","background","default","get_Order_Report","gql","GET_COST_REPORT","GET_PRODUCT_REPORT","get_Employee_Report","GET_FINACAL_REBORT","EAGER_METHODS","useLazyQuery","internalState","execOptionsRef","merged","useQueryResult","eagerMethods","key","method","apply","arguments","EAGER_METHODS_1","_i","executeOptions","__assign","promise","asyncUpdate","then","catch","financialReports","isLoading","Date","setValue","getFinacalRebort","useEffect","console","log","handleSubmit","a","firstDate","seconDate","dateForm","startDate","endDate","status","date","dd","String","getDate","padStart","mm","getMonth","yyyy","getFullYear","startText","endText","onChange","newValue","renderInput","startProps","endProps","Fragment","mx","buttonComp"],"mappings":"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","file":"static/js/41.926ade2b.chunk.js","sourcesContent":["import React from 'react';\nimport Hidden from '@mui/material/Hidden';\nimport Drawer from '@mui/material/Drawer';\nimport Card from '@mui/material/Card';\nimport {Box, drawerClasses, Slide} from '@mui/material';\nimport {useDispatch} from 'react-redux';\nimport PropTypes from 'prop-types';\nimport {onToggleAppDrawer} from '../../../redux/actions';\n\nconst AppSidebar = (props) => {\n  const {isAppDrawerOpen, sidebarContent} = props;\n  const dispatch = useDispatch();\n  return (\n    <Slide direction='right' in mountOnEnter unmountOnExit>\n      <Box\n        sx={{\n          height: '100%',\n          width: {\n            lg: 280,\n          },\n        }}\n      >\n        <Hidden lgUp>\n          <Drawer\n            open={isAppDrawerOpen}\n            onClose={() => dispatch(onToggleAppDrawer())}\n            sx={{\n              position: 'absolute',\n              [`& .${drawerClasses.paper}`]: {\n                width: 280,\n                '& .listItem': {\n                  zIndex: 1305,\n                },\n              },\n            }}\n          >\n            {sidebarContent}\n          </Drawer>\n        </Hidden>\n        <Hidden lgDown>\n          <Card style={{height: '100%'}}>{sidebarContent}</Card>\n        </Hidden>\n      </Box>\n    </Slide>\n  );\n};\n\nexport default AppSidebar;\n\nAppSidebar.propTypes = {\n  isAppDrawerOpen: PropTypes.bool,\n  footer: PropTypes.bool,\n  navStyle: PropTypes.string,\n  fullView: PropTypes.bool,\n  sidebarContent: PropTypes.node,\n};\n","import React from 'react';\nimport PropsTypes from 'prop-types';\nimport Box from '@mui/material/Box';\nimport {NavStyle} from '../../../shared/constants/AppEnums';\n\nconst getMainHeaderHeight = (navStyle, screenSize) => {\n  if (navStyle === NavStyle.BIT_BUCKET) return screenSize >= 1200 ? 0 : 70; // Header Height\n  return screenSize >= 600 ? 70 : 56;\n};\n\nconst AppContainerWrapper = ({children, navStyle, footer, ...rest}) => {\n  return (\n    <Box\n      sx={{\n        display: 'flex',\n        height: {\n          xs: `calc(100vh - ${\n            47 + // AppsHeader Height // apps title block height\n            40 + //Container Padding\n            getMainHeaderHeight(navStyle, 0) +\n            (footer ? 47 : 0)\n          }px) !important`,\n          sm: `calc(100vh - ${\n            47 + // AppsHeader Height\n            40 + //Container Padding\n            getMainHeaderHeight(navStyle, 600) +\n            (footer ? 47 : 0)\n          }px) !important`,\n          md: `calc(100vh - ${\n            47 + // AppsHeader Height\n            60 + //Container Padding\n            getMainHeaderHeight(navStyle, 900) +\n            (footer ? 47 : 0)\n          }px) !important`,\n          lg: `calc(100vh - ${\n            40 + // AppsHeader Height\n            60 + //Container Padding\n            getMainHeaderHeight(navStyle, 1200) +\n            (footer ? 47 : 0)\n          }px) !important`,\n          xl: `calc(100vh - ${\n            40 + // AppsHeader Height\n            100 + //Container Padding\n            getMainHeaderHeight(navStyle, 1536) +\n            (footer ? 57 : 0)\n          }px) !important`,\n        },\n      }}\n      {...rest}\n    >\n      {children}\n    </Box>\n  );\n};\n\nexport default AppContainerWrapper;\n\nAppContainerWrapper.propTypes = {\n  children: PropsTypes.node,\n  navStyle: PropsTypes.string,\n  footer: PropsTypes.bool,\n};\n","import React from 'react';\nimport {useDispatch, useSelector} from 'react-redux';\nimport AppInfoView from '@crema/core/AppInfoView';\nimport {Box, Slide, Zoom} from '@mui/material';\nimport Hidden from '@mui/material/Hidden';\nimport IconButton from '@mui/material/IconButton';\nimport MenuIcon from '@mui/icons-material/Menu';\nimport PropTypes from 'prop-types';\nimport Card from '@mui/material/Card';\n\nimport {onToggleAppDrawer} from '../../../redux/actions';\nimport AppSidebar from './AppSidebar';\nimport {useLayoutContext} from '../../utility/AppContextProvider/LayoutContextProvider';\nimport {Fonts} from '../../../shared/constants/AppEnums';\nimport AppContainerWrapper from './AppContainerWrapper';\n\nconst AppsContainer = (props) => {\n  const dispatch = useDispatch();\n  const isAppDrawerOpen = useSelector(({common}) => common.isAppDrawerOpen);\n  const {footer} = useLayoutContext();\n  const {navStyle} = useLayoutContext();\n  const {title, sidebarContent, fullView, children} = props;\n\n  return (\n    <Box\n      sx={{\n        flex: 1,\n        display: 'flex',\n        flexDirection: 'column',\n        overflow: 'hidden',\n        margin: -4,\n        padding: 4,\n        ...props.sxStyle,\n      }}\n    >\n      <Box\n        sx={{\n          marginTop: fullView ? 0 : -4,\n          display: 'flex',\n          alignItems: 'center',\n          mb: {\n            xs: fullView ? 4 : 2,\n            lg: 4,\n          },\n          mt: {\n            xs: fullView ? 0 : -4,\n            lg: 0,\n          },\n        }}\n      >\n        {fullView ? null : (\n          <Hidden lgUp>\n            <IconButton\n              edge='start'\n              sx={{\n                marginRight: (theme) => theme.spacing(2),\n              }}\n              color='inherit'\n              aria-label='open drawer'\n              onClick={() => dispatch(onToggleAppDrawer())}\n              size='large'\n            >\n              <MenuIcon\n                sx={{\n                  width: 35,\n                  height: 35,\n                }}\n              />\n            </IconButton>\n          </Hidden>\n        )}\n        <Zoom in style={{transitionDelay: '300ms'}}>\n          <Box\n            component='h2'\n            variant='h2'\n            sx={{\n              fontSize: 16,\n              color: 'text.primary',\n              fontWeight: Fonts.SEMI_BOLD,\n            }}\n          >\n            {title}\n          </Box>\n        </Zoom>\n      </Box>\n\n      <AppContainerWrapper navStyle={navStyle} footer={footer}>\n        {sidebarContent ? (\n          <AppSidebar\n            isAppDrawerOpen={isAppDrawerOpen}\n            footer={footer}\n            fullView={fullView}\n            navStyle={navStyle}\n            sidebarContent={sidebarContent}\n          />\n        ) : null}\n\n        <Box\n          sx={{\n            display: 'flex',\n            flexDirection: 'column',\n            width: {\n              xs: '100%',\n              lg: `calc(100% - ${fullView ? 0 : 280}px)`,\n            },\n            pl: {\n              lg: props.fullView ? 0 : 8,\n            },\n          }}\n        >\n          <Slide direction='left' in mountOnEnter unmountOnExit>\n            <Card\n              style={{\n                height: '100%',\n                display: 'flex',\n                flexDirection: 'column',\n                position: 'relative',\n                ...props.cardStyle,\n              }}\n            >\n              {children}\n            </Card>\n          </Slide>\n          <AppInfoView />\n        </Box>\n      </AppContainerWrapper>\n    </Box>\n  );\n};\n\nexport default AppsContainer;\n\nAppsContainer.defaultProps = {\n  title: '',\n};\n\nAppsContainer.propTypes = {\n  title: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  sidebarContent: PropTypes.node,\n  fullView: PropTypes.bool,\n  children: PropTypes.node,\n  sxStyle: PropTypes.object,\n  cardStyle: PropTypes.object,\n};\n","import { invariant } from '../../utilities/globals';\nimport * as React from 'react';\n\nimport { canUseLayoutEffect } from '../../utilities';\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType = realHook || ((\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n) => {\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  const value = getSnapshot();\n  if (\n    // DEVIATION: Using our own __DEV__ polyfill (from ../../utilities/globals).\n    __DEV__ &&\n    !didWarnUncachedGetSnapshot &&\n    // DEVIATION: Not using Object.is because we know our snapshots will never\n    // be exotic primitive values like NaN, which is !== itself.\n    value !== getSnapshot()\n  ) {\n    didWarnUncachedGetSnapshot = true;\n    // DEVIATION: Using invariant.error instead of console.error directly.\n    invariant.error(\n      'The result of getSnapshot should be cached to avoid an infinite loop',\n    );\n  }\n\n  // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n  const [{inst}, forceUpdate] = React.useState({inst: {value, getSnapshot}});\n\n  // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n  if (canUseLayoutEffect) {\n    // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n    // which may seem like a conditional hook, but this code ends up behaving\n    // unconditionally (one way or the other) because canUseLayoutEffect is\n    // constant.\n    React.useLayoutEffect(() => {\n      Object.assign(inst, { value, getSnapshot });\n      // Whenever getSnapshot or subscribe changes, we need to check in the\n      // commit phase if there was an interleaved mutation. In concurrent mode\n      // this can happen all the time, but even in synchronous mode, an earlier\n      // effect may have mutated the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst});\n      }\n    }, [subscribe, value, getSnapshot]);\n  } else {\n    Object.assign(inst, { value, getSnapshot });\n  }\n\n  React.useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({inst});\n    }\n\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(function handleStoreChange() {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst});\n      }\n    });\n  }, [subscribe]);\n\n  return value;\n});\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n","import { invariant } from '../../utilities/globals';\n\nimport {\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore';\nimport { equal } from '@wry/equality';\n\nimport { mergeOptions, OperationVariables, WatchQueryFetchPolicy } from '../../core';\nimport { ApolloContextValue, getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloClient,\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\nimport { canUseWeakMap, canUseWeakSet, compact, isNonEmptyArray, maybeDeepFreeze } from '../../utilities';\n\nconst {\n  prototype: {\n    hasOwnProperty,\n  },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = Object.create(null),\n): QueryResult<TData, TVariables> {\n  return useInternalState(\n    useApolloClient(options.client),\n    query,\n  ).useQuery(options);\n}\n\nexport function useInternalState<TData, TVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n): InternalState<TData, TVariables> {\n  const stateRef = useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  const [_tick, setTick] = useState(0);\n  state.forceUpdate = () => {\n    setTick(tick => tick + 1);\n  };\n\n  return state;\n}\n\nclass InternalState<TData, TVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>,\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  forceUpdate() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n  }\n\n  asyncUpdate() {\n    return new Promise<QueryResult<TData, TVariables>>(resolve => {\n      this.asyncResolveFns.add(resolve);\n      this.optionsToIgnoreOnce.add(this.watchQueryOptions);\n      this.forceUpdate();\n    });\n  }\n\n  private asyncResolveFns = new Set<\n    (result: QueryResult<TData, TVariables>) => void\n  >();\n\n  private optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)<\n    WatchQueryOptions<TVariables, TData>\n  >();\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      useCallback(() => {\n        if (this.renderPromises) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = this.result;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = obsQuery.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          this.setResult(result);\n        };\n\n        const onError = (error: Error) => {\n          const last = obsQuery[\"last\"];\n          subscription.unsubscribe();\n          // Unfortunately, if `lastError` is set in the current\n          // `observableQuery` when the subscription is re-created,\n          // the subscription will immediately receive the error, which will\n          // cause it to terminate again. To avoid this, we first clear\n          // the last error/result from the `observableQuery` before re-starting\n          // the subscription, and restore it afterwards (so the subscription\n          // has a chance to stay open).\n          try {\n            obsQuery.resetLastResults();\n            subscription = obsQuery.subscribe(onNext, onError);\n          } finally {\n            obsQuery[\"last\"] = last;\n          }\n\n          if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = this.result;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            this.setResult({\n              data: (previousResult && previousResult.data) as TData,\n              error: error as ApolloError,\n              loading: false,\n              networkStatus: NetworkStatus.error,\n            });\n          }\n        };\n\n        let subscription = obsQuery.subscribe(onNext, onError);\n\n        return () => subscription.unsubscribe();\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches,\n      ]),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult(),\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    const queryResult = this.toQueryResult(result);\n\n    if (!queryResult.loading && this.asyncResolveFns.size) {\n      this.asyncResolveFns.forEach(resolve => resolve(queryResult));\n      this.asyncResolveFns.clear();\n    }\n\n    return queryResult;\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(\n    options: QueryHookOptions<TData, TVariables>,\n  ) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    // To force this equality test to \"fail,\" thereby reliably triggering\n    // observable.reobserve, add any current WatchQueryOptions object(s) you\n    // want to be ignored to this.optionsToIgnoreOnce. A similar effect could be\n    // achieved by nullifying this.watchQueryOptions so the equality test\n    // immediately fails because currentWatchQueryOptions is null, but this way\n    // we can promise a truthy this.watchQueryOptions at all times.\n    if (\n      this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||\n      !equal(watchQueryOptions, currentWatchQueryOptions)\n    ) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // As advertised in the -Once of this.optionsToIgnoreOnce, this trick is\n        // only good for one forced execution of observable.reobserve per\n        // ignored WatchQueryOptions object, though it is unlikely we will ever\n        // see this exact currentWatchQueryOptions object again here, since we\n        // just replaced this.watchQueryOptions with watchQueryOptions.\n        this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);\n\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === 'standby'\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<\n      Partial<WatchQueryOptions<TVariables, TData>>\n    > = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(\n      this.observable && this.observable.options,\n      this.watchQueryOptions,\n    ));\n\n    return toMerge.reduce(\n      mergeOptions\n    ) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<TVariables, TData> {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (\n        watchQueryOptions.fetchPolicy === 'network-only' ||\n        watchQueryOptions.fetchPolicy === 'cache-and-network'\n      )\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: 'standby',\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = this.observable =\n      this.renderPromises\n        && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n        || this.observable // Reuse this.observable if possible (and not SSR)\n        || this.client.watchQuery(this.getObsQueryOptions());\n\n    this.obsQueryFields = useMemo(() => ({\n      refetch: obsQuery.refetch.bind(obsQuery),\n      reobserve: obsQuery.reobserve.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }), [obsQuery]);\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false ||\n      this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  }\n\n  private handleErrorOrCompleted(result: ApolloQueryResult<TData>) {\n    if (!result.loading) {\n      if (result.error) {\n        this.onError(result.error);\n      } else if (result.data) {\n        this.onCompleted(result.data);\n      }\n    }\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        this.result = this.observable.getCurrentResult()\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>,\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(result, queryResult = {\n      data, // Ensure always defined, even if result.data is missing.\n      ...resultWithoutPartial,\n      ...this.obsQueryFields,\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData,\n    });\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== 'cache-only'\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n","import React, {useState} from 'react';\nimport {useIntl} from 'react-intl';\nimport {Button, Card} from '@mui/material';\nimport CardHeader from '@mui/material/CardHeader';\nimport CardContent from '@mui/material/CardContent';\nimport CodeIcon from '@mui/icons-material/Code';\nimport PropTypes from 'prop-types';\nimport IconButton from '@mui/material/IconButton';\nimport Box from '@mui/material/Box';\nimport AppAnimate from './../../@crema/core/AppAnimate';\nimport {Fonts} from './../../shared/constants/AppEnums';\n\nconst CAppContaner = ({\n  title,\n  description,\n  component: Component,\n  source,\n  buttonCompMethod,\n}) => {\n  const {messages} = useIntl();\n  const [viewSource, setToggleViewSource] = useState(false);\n  const [animation, setAnimation] = useState(false);\n\n  return (\n    <AppAnimate animation='transition.slideUpIn' delay={200}>\n      <Card>\n        <CardHeader\n          sx={{\n            py: 4,\n            pb: 1,\n            px: 5,\n            display: 'flex',\n            alignItems: 'center',\n            minHeight: 50,\n            boxSizing: 'border-box',\n            '& .MuiTypography-h5': {\n              fontSize: 14,\n              fontWeight: Fonts.BOLD,\n              marginBottom: 0.25,\n            },\n          }}\n          title={title}\n          subheader={description}\n          root={{\n            subheader: {\n              fontSize: 13,\n            },\n          }}\n          action={\n            source ? (\n              <Box>\n                <IconButton\n                  aria-label='view code'\n                  onClick={() => {\n                    if (animation) {\n                      setAnimation(!animation);\n                      setTimeout(() => setToggleViewSource(!viewSource), 400);\n                    } else {\n                      setAnimation(!animation);\n                      setToggleViewSource(!viewSource);\n                    }\n                  }}\n                  size='large'\n                >\n                  <CodeIcon />\n                </IconButton>\n              </Box>\n            ) : null\n          }\n        />\n\n        <CardContent sx={{px: 4, pt: 0}}>\n          <Box\n            sx={{\n              width: '100%',\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              p: 4,\n              backgroundColor: (theme) => theme.palette.background.default,\n            }}\n          >\n            <Component />\n          </Box>\n          <Box\n            mt={4}\n            display='flex'\n            justifyContent='flex-end'\n            alignItems='flex-end'\n          >\n            <Button\n              variant='contained'\n              size='medium'\n              onClick={buttonCompMethod}\n            >\n              {messages['reports.datepicker.generate']}\n            </Button>\n          </Box>\n        </CardContent>\n      </Card>\n    </AppAnimate>\n  );\n};\n\nCAppContaner.propTypes = {\n  component: PropTypes.any.isRequired,\n  source: PropTypes.any,\n  title: PropTypes.node.isRequired,\n  description: PropTypes.node,\n  buttonCompMethod: PropTypes.any.isRequired,\n};\n\nexport default CAppContaner;\n","import {gql} from '@apollo/client';\n\nexport const get_Order_Report = gql`\n  query getOrderReport($startDate: Date, $endDate: Date, $status: String) {\n    getOrderReport(\n      start_date: $startDate\n      end_date: $endDate\n      status: $status\n    ) {\n      date_start\n      date_end\n      revenue\n      cost\n      profit\n      count\n      pendingCount\n      inDilveryCount\n      completeCount\n      CanceldCount\n      inprogressCount\n      shipingExp\n      discount\n    }\n  }\n`;\n\nexport const GET_COST_REPORT = gql`\n  query getCostRebort($startDate: Date, $endDate: Date) {\n    getCostRebort(start_date: $startDate, end_date: $endDate) {\n      date_start\n      date_end\n      count\n      totalCost\n      runingCost {\n        id\n        amount\n        time\n        name\n        date\n        short_desc\n      }\n    }\n  }\n`;\n\nexport const GET_PRODUCT_REPORT = gql`\n  query getProductRebort($startDate: Date, $endDate: Date) {\n    getProductRebort(start_date: $startDate, end_date: $endDate) {\n      date_start\n      date_end\n      productReb {\n        product {\n          id\n          name\n          slug\n          price\n          sale_price\n          review\n          ratings\n          until\n          stock\n          top\n          featured\n          new\n          short_desc\n          category {\n            name\n            slug\n          }\n          brands {\n            name\n            slug\n          }\n          pictures {\n            width\n            height\n            url\n          }\n          sm_pictures {\n            width\n            height\n            url\n          }\n          variants {\n            color\n            color_name\n            price\n            size {\n              name\n            }\n          }\n        }\n        dataSumation {\n          totalSingleSaleCouont\n          totalSingleDamgedCount\n          totalSingleInStokCount\n          totalSingleClistSalesPriceCount\n          totalSingleClintSalesCount\n          totalSingleVendorSalesCounter\n          totalSingleVendorSalesPriecsCount\n          totalSingleInStockCostPrice\n          totalSingleLoseDamged\n        }\n      }\n      productTypeCount\n      totalSaleCouont\n      totalDamgedCount\n      totalInStokCount\n      totalclintSalesCount\n      totalclistSalesPriceCount\n      totalVendorSalesCounter\n      totalVendorSalesPriecsCount\n      totalInStockCostPrice\n      totalLoseDamged\n    }\n  }\n`;\n\nexport const get_Employee_Report = gql`\n  query getEmployeeReport($startDate: Date, $endDate: Date) {\n    getEmployeeReport(start_date: $startDate, end_date: $endDate) {\n      date_start\n      date_end\n      totalSalaryPayid\n      count\n      singleEmplpoyeeRebort {\n        employee {\n          addDate\n          address\n          email\n          id\n          name\n          phone_Number\n          role\n          salary\n          password\n          time\n        }\n        totalSinglSalaryPaid\n      }\n    }\n  }\n`;\n\nexport const GET_FINACAL_REBORT = gql`\n  query getFinacalRebort($startDate: Date, $endDate: Date) {\n    getFinacalRebort(start_date: $startDate, end_date: $endDate) {\n      date_start\n      date_end\n      revenue\n      profit\n      cost\n      totalOrderCount\n      totalOrderProdactCost\n      totalSalaryPaid\n      totalDamegdPdocuctCost\n      totalproductTypeCount\n      totalPdocuctSaleCouont\n      totalProduactInStockCount\n      totalRuningCostInvoiceCount\n      totalRuningCost\n      pendingOrderCount\n      inDilveryOrderCount\n      completeOrderCount\n      CanceldOrderCount\n      inprogressOrderCount\n      TotalOrderShipingExp\n      TotalOrderDiscount\n    }\n  }\n`;\n","import { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { useCallback, useMemo, useRef } from 'react';\n\nimport { OperationVariables } from '../../core';\nimport { mergeOptions } from '../../utilities';\nimport {\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  QueryResult,\n} from '../types/types';\nimport { useInternalState } from './useQuery';\nimport { useApolloClient } from './useApolloClient';\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  'refetch',\n  'reobserve',\n  'fetchMore',\n  'updateQuery',\n  'startPolling',\n  'subscribeToMore',\n] as const;\n\nexport function useLazyQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<TData, TVariables>\n): LazyQueryResultTuple<TData, TVariables> {\n  const internalState = useInternalState(\n    useApolloClient(options && options.client),\n    query,\n  );\n\n  const execOptionsRef = useRef<Partial<LazyQueryHookOptions<TData, TVariables>>>();\n  const merged = execOptionsRef.current\n    ? mergeOptions(options, execOptionsRef.current)\n    : options;\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> =\n    Object.assign(useQueryResult, {\n      called: !!execOptionsRef.current,\n    });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdate();\n        }\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = useCallback<\n    LazyQueryResultTuple<TData, TVariables>[0]\n  >(executeOptions => {\n    execOptionsRef.current = executeOptions ? {\n      ...executeOptions,\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n    } : {\n      fetchPolicy: initialFetchPolicy,\n    };\n\n    const promise = internalState\n      .asyncUpdate() // Like internalState.forceUpdate, but returns a Promise.\n      .then(queryResult => Object.assign(queryResult, eagerMethods));\n\n    // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n    promise.catch(() => {});\n\n    return promise;\n  }, []);\n\n  return [execute, result];\n}\n","import React, {useState, useEffect} from 'react';\nimport {useIntl} from 'react-intl';\nimport AppsContainer from '../../../@crema/core/AppsContainer';\n// import AppComponentCard from '@crema/core/AppComponentCard';\nimport {AppComponentHeader} from '@crema';\nimport {TextField} from '@mui/material';\nimport {Box} from '@mui/system';\nimport {MobileDateRangePicker} from '@mui/lab';\nimport CAppContaner from 'components/CappContaner';\nimport {useLazyQuery} from '@apollo/client';\nimport {GET_FINACAL_REBORT} from 'query/orderReoprt/getOrder';\n\nconst financialReports = () => {\n  const {messages} = useIntl();\n  const isLoading = useState(false);\n  const [value, setValue] = React.useState([new Date(), new Date()]);\n  const [getFinacalRebort, {loading, error, data}] =\n    useLazyQuery(GET_FINACAL_REBORT);\n  useEffect(() => {\n    console.log(error);\n    console.log(data);\n  }, [loading]);\n  const handleSubmit = async () => {\n    let firstDate = '';\n    let seconDate = '';\n    if (value[0] != null) firstDate = dateForm(value[0]);\n    if (value[1] != null) seconDate = dateForm(value[1]);\n    getFinacalRebort({\n      variables: {startDate: firstDate, endDate: seconDate, status: 'asdasd'},\n    });\n  };\n\n  const dateForm = (date) => {\n    var dd = String(date.getDate()).padStart(2, '0');\n    var mm = String(date.getMonth() + 1).padStart(2, '0'); //January is 0!\n    var yyyy = date.getFullYear();\n    date = mm + '/' + dd + '/' + yyyy;\n    return date;\n  };\n  return (\n    <>\n      <AppComponentHeader\n        cardStyle={{height: 'auto'}}\n        fullView\n        title={messages['sidebar.reports.financialReports']}\n      />\n      <CAppContaner\n        title={messages['Datepicker.title']}\n        buttonCompMethod={handleSubmit}\n        component={() => (\n          <>\n            <MobileDateRangePicker\n              startText={messages['sidebar.reports.startdate']}\n              endText={messages['sidebar.reports.enddate']}\n              value={value}\n              onChange={(newValue) => {\n                setValue(newValue);\n              }}\n              renderInput={(startProps, endProps) => (\n                <React.Fragment>\n                  <TextField {...startProps} />\n                  <Box sx={{mx: 2}}> to </Box>\n                  <TextField {...endProps} />\n                </React.Fragment>\n              )}\n              buttonComp={() => {}}\n            />\n          </>\n        )}\n      />\n\n      {isLoading ? <></> : <AppsContainer fullView></AppsContainer>}\n    </>\n  );\n};\n\nexport default financialReports;\n"],"sourceRoot":""}